<h1 style="text-align:center">
AFANASY
</h1>
<h2 style="text-align:center">
FREE AND OPEN SOURCE
</h2>
<h2 style="text-align:center">
RENDER FARM MANAGER
</h2>

<p>
Afanasy is a free and open source tool to control remote computing.
You can compute something more quickly using render farm - remote computers connected by network.
Afanasy designed for computer graphics (3d rendering and 2d compositing) parallel calculation.
It can compute different frames (or even parts of frames) on several computers simultaneously.
</p>
<p>
Afanasy provides render farm monitoring.
It is very important to watch computers resources during render process.
You can see what kind of resource (CPU, memory, network etc.) is more needed to render.
It is very useful to know what are farm hosts doing.
</p>
<p>
Afanasy engine simple runs different command lines on hosts and controls processes running.
You can use Afanasy to parallel calculate anything you can describe (split) through command lines.
</p>


<div class="cnavblock" style="width:1000px;height:750px;margin:0;padding:0;">
<h3>Schema</h3>

<div class="cnavabs" style="left:0px;top:-100px;width:1000px;height:750px;">

<div class="arrows" style="position:absolute;opacity:0.5;width:1000px;height:750px;/*border:1px solid #000;*/"
arrows="{[
[[0,0,0,2],[300,180],[300,380]],
[[0,0,0,2],[320,380],[320,180]],
[[100,0,200,2],[430,180],[430,380]],
[[100,0,200,2],[450,380],[450,180]],
[[100,0,200,2],[540,180],[540,670],[490,670]],
[[100,0,200,2],[490,690],[560,690],[560,180]],

[[0,0,0,2],[120,530],[120,510],[200,480],[380,480]],
[[0,0,0,2],[150,565],[260,565]],
[[0,0,0,2],[260,580],[150,580]]

]}">
</div>

<div style="left:240px;top:100px;width:510px;height:70px;box-shadow:0 0 5px #230 inset;" class="cnavblock">
<b>GUI</b>
<div style="left:10px;top:40px;width:100px;height:20px;box-shadow:0 0 5px #230 inset;" class="cnavblock">
<b>AfWatch</b></div>
<div style="left:140px;top:40px;width:100px;height:20px;box-shadow:0 0 5px #230 inset;" class="cnavblock">
<b>Browser</b></div>
<div style="left:270px;top:40px;width:100px;height:20px;box-shadow:0 0 5px #230 inset;" class="cnavblock">
<b>Visor</b></div>
<div style="left:400px;top:40px;width:100px;height:20px;" class="cnavblock">
<b>Keeper</b></div>
</div>

<div style="left:0px;top:100px;width:200px;height:250px;" class="cnavblock">
<b>Render</b>
<div style="left:10px;top:40px;width:180px;height:20px;" class="cnavblock">
<b>command</b></div>
<div style="left:10px;top:120px;width:100px;height:20px;" class="cnavblock">
<b>pathsmap</b></div>
<div style="left:90px;top:170px;width:100px;height:20px;" class="cnavblock info" info="
Location:
">
<b>parser</b></div>
<div style="left:10px;top:220px;width:100px;height:20px;" class="cnavblock">
<b>service</b></div>
</div>

<div style="left:240px;top:300px;width:270px;height:420px;" class="cnavblock">
<b>Server</b>

<div style="left:20px;top:40px;width:230px;height:150px;" class="cnavblock">
<b>AfServer</b>

<div style="left:10px;top:40px;width:100px;height:20px;" class="cnavblock">
<b>binary</b></div>

<div style="left:120px;top:40px;width:100px;height:20px;" class="cnavblock">
<b>HTTP</b></div>

<div style="left:120px;top:110px;width:100px;height:20px;" class="cnavblock">
<b>JSON</b></div>

</div>

<div style="left:20px;top:250px;width:230px;height:20px;" class="cnavblock">
<b>SQL Database</b></div>

<div style="left:20px;top:330px;width:230px;height:70px;" class="cnavblock">
<b>Web Visor</b><br/>
HTTP Server<br/>
PHP with SQL API<br/>
</div>

</div>

<div style="left:50px;top:530px;width:100px;height:40px;" class="cnavblock">
<b>AfCmd<br/>CLI</b></div>

<div style="left:600px;top:430px;width:100px;height:40px;" class="cnavblock">
<b>Python<br/>API</b></div>

<div style="left:600px;top:550px;width:100px;height:40px;" class="cnavblock">
<b>afjob.py<br/>CLI</b></div>

<div style="left:800px;top:100px;width:200px;height:320px;" class="cnavblock">
<b>Software<br/>Integration</b>
<div style="left:10px;top:60px;width:180px;height:100px;" class="cnavblock">
<b>python</b><br/>
With internal Python<br/>
Blender, Nuke, Houdini, XSI ...<br/>
</div>
<div style="left:10px;top:200px;width:180px;height:100px;" class="cnavblock">
<b>script</b><br/>
construct and launch a system command<br/>
Max, After Effects ...<br/>
</div>
</div>

<div style="left:810px;top:540px;width:180px;height:70px;" class="cnavblock info" info="
Location:<br/>
">
<b>AfStarter</b><br/>
Stand Alone<br/>Submitter Dialog<br/>
</div>

</div>
</div>


<div style="float:right;text-align:center;margin:10px;">

<b>Watch Renders</b><br/>
<img src="images/afanasy/watch/renders_features.png" alt="watch/renders.png"/><br/>

<b>Watch Jobs</b><br/>
<img src="images/afanasy/watch/jobs.png" alt="watch/jobs.png"/><br/>

<b>1 000 000 Tasks Job:</b><br/>
<img src="images/afanasy/watch/million_job.png" alt="watch/million_job.png"/><br/>

<b>Watch Job Tasks</b><br/>
<img src="images/afanasy/watch/job_tasks_block.png" alt="watch/job_tasks_block.png"/><br/>

<b>Watch Users</b><br/>
<img src="images/afanasy/watch/users.png" alt="watch/users.png"/><br/>

<!--
<b>Web Visor Statistics Chart - Service Type / Tasks Number</b><br/>
<img width="400" height="300" src="images/afanasy/visor/chart_service_tasks.png" alt="visor/chart_service_tasks.png"/><br/>

<b>Web Visor Statistics Chart - User Name / Jobs Quantity</b><br/>
<img width="400" height="300"  src="images/afanasy/visor/chart_user_jobs.png" alt="visor/chart_user_jobs.png"/><br/>
-->
</div>


<h2>Features:</h2>

<h4>Render computer resources monitoring.</h4>
<p>
You can monitor CPU usage: User, Nice, System, I/O Wait and Load Average.
Memory, Swap and HDD usage. Network traffic.
Disk I/O operations speed and utilization percentage.
This can help you to diagnose what slows rendering process.
Especially swap, I/O wait and network traffic.
</p><p>
You can write your own custom resource(s) meter(s) on python. And Watch will plot their graphs.
</p>

<h4>Multiply Tasks Renders (clients, slaves, hosts)</h4>
<p>
Render can run several tasks at the same time.<br/>
</p><p>
Useful for "powerful" hosts with several CPUs.
Render and Task has a capacity attribute, each task checks available capacity on render, and if its enough,
task launches and take its capacity value from render.<br/>
</p>
<h5>Tasks can variate capacity 'on-the-fly'</h5>
Capacity variation can be described through its minimum and maximum coefficients.
</p>

<h4>Paths Map</h4>
<p>
Every host can has different paths and a map to translate paths to server and from server.
With this feature you can setup a multi-OS render.
You can use different operating systems on farm hosts and to submit jobs from any OS to render it on any OS.
</p>

<h4>Dependencies</h4>
<p>
Job can depends on other job(s) of the same user (<i>depend mask</i>) or on some job(s) from any user (<i>global depend mask</i>).
Job will wait other jobs to be done matching this mask regular expression (Afanasy uses Qt Regular Expressions, they are Perl-like).
</p><p>
Job Block can wait other block(s) to be done (<i>depend mask</i>).
Block tasks can wait other block tasks to be done (<i>tasks depend mask</i>).
</p>
<h5>Sub Task Dependence</h5>
<p>
Tasks can wait only some part of other task to be done.
Useful to render simulations.
First frames of a simulation can be started to render without waiting the whole simulation to be done.
</p>

<h4>Errors Solving</h4>
<p>
Job Errors Hosts List - block store host names where error was occurred and number of errors for each host.
If this number greater it's limit, block will 'avoid' this host (not to run tasks on render with such hostname).<br/>
</p><p>
Tasks Errors Hosts List - the same as described above, but for each task.<br/>
</p><p>
Tasks Auto Retry - maximum number of errors to retry task automatically.
</p><p>
Tasks Maximum Run Time - the time after running considered as an error task.
</p><p>
Errors Forgive Time - time from last host error to forgive all it's errors (remove from error hosts list).
</p><p>
User define this default values for his new jobs and can to override them in each job, watch and reset any error hosts list.
</p>

<h4>Services Limits - Software Licenses Setup</h4>
<p>
You can describe various services (tasks) limits:<br/>
- Maximum number of total service starts on an entire farm.<br/>
- Maximum number of hosts which started a service (each host can start several tasks of a service).<br/>
- Maximum number of service starts on each host.<br/>
</p>

<h4>Priorities</h4>
<p>
User and job with greater priority can get more hosts.
</p>

<h4>Hosts Masks</h4>
<p>
Users and Jobs can have a hosts names mask to be able to run on and exclude mask for hosts to avoid.
</p>

<h4>Maximum Running Tasks Number</h4>
<p>
Users and Jobs can have a limit for maximum running tasks number - no new tasks will be started above this limit.
</p>
<h5>Maximum Running Tasks Per Host</h5>
<p>
You can limit job (and block) to start tasks on the same host.
</p>

<h4>JSON Protocol</h4>
<p>
Any information can be send ti and retrieved from server via JSON.
You can send jobs and write custom GUI.
</p>

<h4>Python API</h4>
<p>
You can create and send job using Python.
Setup services and parsers through Python classes inherited from base service and parser.<br/>
</p>

<h4>Services and Parsers</h4>
<p>
Service - 'block tasks type', for example: 'nuke', 'mantra', 'blender', 'movgen', 'maya'.<br/>
</p>
<p>
Service setups a default task output parser type (which can be overridden later).
Services python classes all inherited a base 'service' class.
Service class describes command line manipulations, such as apply paths map.
</p>
<p>
Parser - read task output to calculate running progress.
Parsers are python classes and can be combined (multiply inheritance),
for example: 'hbatch_mantra' - inherits 'hbatch' and 'mantra' parsers to listen to tasks when Houdini generates a files for mantra,
such parser listen for frames switching (when several frames per render set) and calculates valid percentage.<br/>
Parser can produce errors or warnings if it founds "bad" text.
So render can stop task with error if it produced bad output.
</p>

<h4>Job - Block - Task</h4>
<p>
Job consists of blocks, which produce tasks.
There are two types of blocks <i>numeric</i> and not.
Numeric block don't store tasks data, it generates tasks 'on-the-fly' by some rules.
Not numeric blocks contains data for each task.
Task inherits most attributes from block (for example all block tasks has the same working directory).
But some other attributes individual (commands for example).
</p>
<h5>1 000 000 Tasks Job !</h5>
As Tasks are generated by job blocks "on demand",
Afanasy (and Server and GUI) can handle <i>numeric</i> blocks with huge tasks number.
</p>

<h4>Farm setup</h4>
<p>
Map hosts names and their abilities through patterns described in JSON file.
You can describe job and block '<i>need</i>' properties to be able to run only on hosts which satisfy this needs(OS, free memory etc.).
Server can reload this file (and reconfigure itself) "on-the-fly", without restart and keep tasks running.
</p>

<h4>Web Visor</h4>
<p>
Web interface to Afanasy SQL database to show various tables and statistics diagrams.
</p>

<h4>SQL Database Connection</h4>
<p>
Afanasy stores jobs and users information in database.
It get this information back on start.
So you can shut down AfServer, and it will restore it's state on start again.
Also you can type any SQL query to get some information yourself.
</p>

<h4>Command Line Interface</h4>
<p>
Afanasy has a command line interface for various purposes.
You can set some server parameter "on-the-fly".
Change some user, job, host attributes.
Query users, jobs, hosts attributes and traffic statistics.
</p>

<h4>Python Job Example</h4>
<pre>
#!/usr/bin/env python

import af

job = af.Job('example job')

block = af.Block('block of tasks')  
block.setWorkingDirectory('/home')  

task = af.Task('simple task')
task.setCommand('ls -l')

block.tasks.append(task)
job.blocks.append(block)

job.send()
</pre>

<!--p style="clear:both"></p-->

<h4>JSON Job Example</h4>
<pre>
{
   "job":
   {
      "name"                : "job name",
      "user_name"           : "jimmy",
      "host_name"           : "host",
      "blocks":[
      {
        "name"              : "Nuke",
        "tasks_name"        : "frames @#@-@#@",
        "service"           : "nuke",
        "parser"            : "nuke",
        "frame_first"       : 1,
        "frame_last"        : 100,
        "frames_per_task"   : 10,
        "frames_inc"        : 2,
        "command"           : "nuke -F@#@,@#@ -x scene.nk -X Write1",
        "working_directory" : "/home/jimmy/work",
        "files"             : "img_L.@####@.jpg;img_R.@####@.jpg"
      }
      ],
      "command_post"        : "deletefiles path/to/some.scene",
   }
}
</pre>
<p>
 * This is an example of a job with a "numeric" block.
Tasks will be created automatically on demand, and on server and on GUI side.
By such "on-the-fly" tasks creation way Afanasy can handle jobs with a huge tasks number.
</p>

<p>
You can write any custom job directly in python, or use some GUI to generate jobs. Use some already written job generators (see <i>'Software Integration'</i> chapter) or write your own.
</p>

<h4>Farm Patterns Example</h4>
<pre>
{"farm":{
   "":"Copy this file into 'farm.json' and describe you own",

   "":"You can limit service on your farm:",
   "":"'maxhosts' - maximum number if various hosts (renders) service can run on",
   "":"'maxcount' - total maximum number of service starts, no matter on the same host or not",
   "limits":[
      {"service":"service_a", "maxhosts":10, "maxcount":20},
      {"service":"service_b", "maxhosts":10, "maxcount":20}
   ],

   "patterns":[
   {
      "name":"Some Host",
      "mask":".*",
         "":"Mask '.*' will match any render name. So here defined some default settings for any host.",

      "description":"Default machine",
      "capacity":1100,
      "maxtasks":10,
      "power":1000,

      "services":[
         {"name":"generic"},
         {"name":"system"},
         {"name":"wakeonlan"},
         {"name":"postcmd"},

         {"name":"afterfx"},
         {"name":"blender"},
         {"name":"blender"},
         {"name":"c4d"},
         {"name":"hbatch"},
         {"name":"hbatch_prman"},
         {"name":"hbatch_mantra"},
         {"name":"mantra"},
         {"name":"max"},
         {"name":"maya"},
         {"name":"maya_delight"},
         {"name":"maya_mental"},
         {"name":"mentalray"},
         {"name":"movgen"},
         {"name":"nuke"},
         {"name":"prman"},
         {"name":"shake"},
         {"name":"xsi"},
         {"name":"yafray"}
      ],

         "":"Comment it if you agree with build in os detection (names)",
      "-os":"linux mac windows",
         "":"You can specify several platforms, if host can take tasks for diffent platforms."

   },{

      "name":"Render",
      "mask":"lrf.*",
      "description":"Linux render farm.",
      "capacity":8800,
      "maxtasks":80,
      "power":8000,
      "remservices":["afterfx","max","xsi"]

   },{

      "name":"Server",
      "mask":"server.*|srv.*|cap.*",
      "description":"Captain.",
      "capacity":1100,
      "maxtasks":2,
      "power":1000,
      "remservices":[],
      "services":[
         {"name":"generic","count":1},
         {"name":"system"},
         {"name":"movgen"},
         {"name":"wakeonlan"},
         {"name":"postcmd"}
      ]

   }]
}}
</pre>
<p>
When some machine registers on server, it finds last pattern with mask that match it's hostname. So '.*' first mask put at the top to give any machine some properties.
</p>

